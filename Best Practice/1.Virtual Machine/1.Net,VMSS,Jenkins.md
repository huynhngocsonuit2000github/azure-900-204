# 1. Set up Dotnet API Application within versioning

- Create Dotnet API Application

```sh
dotnet new webapi -n MySimpleApi
cd MySimpleApi
```

- Update the `Program.cs` file to create the API

```cs
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

app.UseSwagger();
app.UseSwaggerUI();

app.MapGet("/", () => "Hello from .NET 8 API!");
app.MapGet("/api/hello/{name}", (string name) => $"Hello, {name}! Welcome to .NET 8 API!");
app.MapGet("/api/user", () => new { Id = 1, Name = "Son", Role = "Admin" });

app.Run();
```

- Publish the code

```sh
dotnet publish -c Release -o ./publish
```

- Create separated branch and push to Azure Repository

```sh
git checkout -b "az-vmss-dotnet-v1"
```

- Copy the build and push

```sh
git push --set-upstream origin az-vmss-dotnet-v1
```

# 2. Set up VMSS and deploy with the Dotnet Build

- Set up variables

```sh
# Variables
RESOURCE_GROUP="vmss-dotnet-rg"
LOCATION="eastasia"
VMSS_NAME="vmss-dotnet-api"
ADMIN_USER="azureuser"
ADMIN_PASS="Azureuser@123"

# GitHub release artifact (ZIP of ./publish folder)
APP_ZIP_URL="https://github.com/huynhngocsonuit2000github/az-packages/blob/az-vmss-dotnet-v1/publish.zip"
```

- Create Resource Group

```sh
az group create --name $RESOURCE_GROUP --location $LOCATION
```

- Create Networking + Load Balancer

```bash
# Public IP
az network public-ip create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-pip \
  --sku Standard \
  --allocation-method static

# VNet + Subnet
az network vnet create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-vnet \
  --subnet-name ${VMSS_NAME}-subnet

# Load Balancer
az network lb create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-lb \
  --sku Standard \
  --frontend-ip-name frontend \
  --backend-pool-name backend \
  --public-ip-address ${VMSS_NAME}-pip
```

- Create Health Probe + LB Rule

```bash
az network lb probe create \
  --resource-group $RESOURCE_GROUP \
  --lb-name ${VMSS_NAME}-lb \
  --name http-probe \
  --protocol tcp \
  --port 80

az network lb rule create \
  --resource-group $RESOURCE_GROUP \
  --lb-name ${VMSS_NAME}-lb \
  --name http-rule \
  --protocol Tcp \
  --frontend-port 80 \
  --backend-port 80 \
  --frontend-ip-name frontend \
  --backend-pool-name backend \
  --probe-name http-probe \
  --disable-outbound-snat true
```

- Create SNAT outbound rule for LB

```sh
az network lb outbound-rule create \
  --resource-group $RESOURCE_GROUP \
  --lb-name ${VMSS_NAME}-lb \
  --name outboundRule \
  --frontend-ip-configs frontend \
  --protocol All \
  --idle-timeout 4 \
  --enable-tcp-reset true \
  --address-pool backend
```

- Create Custom Cloud-Init Script (Install .NET + Deploy API), to be applied to VMSS

```bash
cat <<'EOF' > ./scripts/cloud-init-dotnet.yml
#cloud-config
package_update: true
packages:
  - ca-certificates
  - curl
  - wget
  - unzip
  - git

write_files:
  - path: /etc/systemd/system/mysimpleapi.service
    permissions: '0644'
    content: |
      [Unit]
      Description=My .NET 8 API
      After=network-online.target
      Wants=network-online.target

      [Service]
      WorkingDirectory=/app/mysimpleapi
      ExecStart=/usr/local/dotnet/dotnet /app/mysimpleapi/publish/MySimpleApi.dll
      Restart=always
      RestartSec=5
      Environment=ASPNETCORE_ENVIRONMENT=Production
      Environment=ASPNETCORE_URLS=http://0.0.0.0:80

      [Install]
      WantedBy=multi-user.target

runcmd:
  # 0) Ensure TLS roots up to date
  - update-ca-certificates

  # 1) Install .NET 8 runtime into /usr/local/dotnet and symlink 'dotnet'
  - mkdir -p /usr/local/dotnet
  - curl -fsSL https://dot.net/v1/dotnet-install.sh -o /tmp/dotnet-install.sh
  - bash /tmp/dotnet-install.sh --channel 8.0 --install-dir /usr/local/dotnet
  - ln -sf /usr/local/dotnet/dotnet /usr/local/bin/dotnet

  # 2) Prepare app dir
  - mkdir -p /app/mysimpleapi

  # 3) Clone repo and switch to the branch, then locate publish.zip
  - |
      set -e
      REPO_URL="https://github.com/huynhngocsonuit2000github/az-packages.git"
      BRANCH="az-vmss-dotnet-v1"
      WORKDIR="/opt/az-packages"

      echo "[GIT] Cloning $REPO_URL (branch: $BRANCH)"
      rm -rf "$WORKDIR"
      git clone --depth 1 --branch "$BRANCH" --single-branch "$REPO_URL" "$WORKDIR"

      echo "[GIT] Searching for publish.zip"
      PUBZIP="$(find "$WORKDIR" -maxdepth 3 -type f -name 'publish.zip' | head -n1)"
      if [ -z "$PUBZIP" ]; then
        echo "ERROR: publish.zip not found in $WORKDIR (branch $BRANCH)" | tee /root/app-deploy-error.txt
        exit 1
      fi
      echo "[GIT] Found: $PUBZIP"

      echo "[APP] Extracting publish.zip to /app/mysimpleapi"
      rm -rf /app/mysimpleapi/*
      unzip -o "$PUBZIP" -d /app/mysimpleapi

  # 4) Enable + start service
  - systemctl daemon-reload
  - systemctl enable mysimpleapi
  - systemctl restart mysimpleapi

  # 5) Log final status for quick troubleshooting
  - systemctl status mysimpleapi --no-pager -l > /root/mysimpleapi.status.txt || true
EOF
```

- Create VMSS with Encode your file into a single line

```sh
az vmss create \
  -g "$RESOURCE_GROUP" \
  -n "$VMSS_NAME" \
  --image Ubuntu2204 \
  --upgrade-policy-mode manual \
  --admin-username "$ADMIN_USER" \
  --admin-password "$ADMIN_PASS" \
  --custom-data ./scripts/cloud-init-dotnet.yml \
  --vnet-name "${VMSS_NAME}-vnet" \
  --subnet "${VMSS_NAME}-subnet" \
  --lb "${VMSS_NAME}-lb" \
  --backend-pool-name backend \
  --instance-count 2 \
  --vm-sku Standard_B1s
```

- Open Port 80 via NSG for the VMSS

```sh
az network nsg create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-nsg

az network nsg rule create \
  --resource-group $RESOURCE_GROUP \
  --nsg-name ${VMSS_NAME}-nsg \
  --name allow-http \
  --protocol Tcp \
  --direction Inbound \
  --priority 1000 \
  --source-address-prefixes '*' \
  --source-port-ranges '*' \
  --destination-port-ranges 80 \
  --access Allow

az network vnet subnet update \
  --resource-group $RESOURCE_GROUP \
  --vnet-name ${VMSS_NAME}-vnet \
  --name ${VMSS_NAME}-subnet \
  --network-security-group ${VMSS_NAME}-nsg
```

- We can check the failed log inside the VMSS instance

```sh
sudo cat /var/log/cloud-init-output.log
```

- _For some reason, we need to update the script file and reboot the VMSS instance. Update the model with the new file_

```sh
az vmss update \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --set virtualMachineProfile.osProfile.customData="$(base64 -w0 ./scripts/cloud-init-dotnet.yml)"
```

- _Then delete all the VMSS instance, the Azure will automatically recreate all the instances using the same model_

```sh
az vmss delete-instances \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --instance-ids '*'
```

- _Force recreate two instance_

```sh
az vmss scale \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --new-capacity 2
```

- Verify on the VM

```sh
sudo systemctl status mysimpleapi --no-pager -l
sudo ss -tulpen | grep :80
curl -I http://localhost/
```

- Access to the public IP to verify the deployment

![Full flow deployment](./images/FullFlowVMSS,LB.png)

# 3. Using Custom Script Extension to achieve the Rolling Deployment

- Set up environment for next deployment

```sh
REPO_URL="https://github.com/huynhngocsonuit2000github/az-packages.git"
NEW_BRANCH="az-vmss-dotnet-v3"
APP_DIR="/app/mysimpleapi"
SERVICE="mysimpleapi"
```

- Build the protected settings JSON with an inline script

```sh
cat >./scripts/cse-redeploy-all.json <<'JSON'
{
  "commandToExecute": "bash -lc 'set -euo pipefail; \
    sudo apt-get update -y; \
    sudo apt-get install -y git unzip ca-certificates >/dev/null; \
    sudo update-ca-certificates || true; \
    echo \"[GIT] Clone REPO_URL @ BRANCH\"; \
    sudo rm -rf /opt/az-packages; \
    sudo git clone --depth 1 --branch BRANCH --single-branch REPO_URL /opt/az-packages; \
    PUBZIP=$(find /opt/az-packages -maxdepth 3 -type f -name publish.zip | head -n1); \
    test -n \"$PUBZIP\" || { echo \"publish.zip not found\" >&2; exit 1; }; \
    echo \"[APP] Replace APP_DIR\"; \
    sudo mkdir -p APP_DIR; \
    sudo rm -rf APP_DIR/*; \
    sudo unzip -o \"$PUBZIP\" -d APP_DIR >/dev/null; \
    echo \"[SYSTEMD] Restart SERVICE\"; \
    sudo systemctl daemon-reload; \
    sudo systemctl restart SERVICE; \
    echo \"branch: BRANCH\" | sudo tee APP_DIR/RELEASE >/dev/null; \
    echo \"[DONE] Deployed BRANCH\"'"
}
JSON

# Fill placeholders safely
sed -i '' -e "s|REPO_URL|$REPO_URL|g" ./scripts/cse-redeploy-all.json
sed -i '' -e "s|BRANCH|$NEW_BRANCH|g" ./scripts/cse-redeploy-all.json
sed -i '' -e "s|APP_DIR|$APP_DIR|g" ./scripts/cse-redeploy-all.json
sed -i '' -e "s|SERVICE|$SERVICE|g" ./scripts/cse-redeploy-all.json
```

- Apply/update the extension on the VMSS model

```sh
az vmss extension set \
  --resource-group "$RG" \
  --vmss-name "$VMSS" \
  --publisher Microsoft.Azure.Extensions \
  --name CustomScript \
  --version 2.1 \
  --protected-settings ./scripts/cse-redeploy-all.json
```

- _Switch the VMSS to Manual mode at once_

```sh
az vmss update -g "$RG" -n "$VMSS" --set upgradePolicy.mode=Manual
```

- Start Rolling upgrade

```sh
az vmss update-instances \
  --resource-group "$RG" \
  --name "$VMSS" \
  --instance-ids "*"
```

- Verify the new deployment
  ![alt text](./images/NewDeployment.png)

# 4. Set up Jenkins to CI/CD

- Set up jenkins at https://huynhngocsonuit2000.atlassian.net/wiki/spaces/~7120204a859d49d075451890027b2fb599f886/pages/2523271/Jenkins

- Create the Azure pipeline

```groovy
// todo

```

- Because the Jenkins runs non-interactively, so we need a service principal (app registration) to do `az login --service-principal`

```sh
# 0) Pick your scope (subscription or just a resource group)
SUBSCRIPTION_ID=$(az account show --query id -o tsv)
TENANT_ID=$(az account show --query tenantId -o tsv)
RG="vmss-dotnet-rg"   # the resource group we will need to grant permission

# 1) Create a service principal scoped to the resource group (least privilege boundary)
APP_NAME="jenkins-vmss-deployer-$(date +%s)"
az ad sp create-for-rbac \
  --name "$APP_NAME" \
  --role Contributor \
  --scopes "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RG}" \
  --years 1

# Output looks like:
# {
#   "appId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",   # == Client ID
#   "displayName": "jenkins-vmss-deployer-...",
#   "password": "xxxxxxxx-CLIENT-SECRET-xxxxxxxx",     # == Client Secret
#   "tenant": "yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy"   # == Tenant ID
# }
```

- Take these and put into Jenkins Credentials (Secret text):

  - az-subscription-id → $SUBSCRIPTION_ID
  - az-tenant-id → "tenant" from the output (or $TENANT_ID)
  - az-client-id → "appId"
  - az-client-secret → "password"

- Add 4 credential

  - ID: `az-subscription-id` (secret text, Subscription GUID ID)
  - ID: `az-tenant-id` (secret text, Directory - Tenant GUID ID)
  - ID: `az-client-id` (secret text, Tenant ID we just created for the scope)
  - ID: `az-client-secret` (secret text, Password just got from the command)

- Then in the Jenkins it can login with

```sh
az login --service-principal \
  --username "$AZ_CLIENT_ID" \
  --password "$AZ_CLIENT_SECRET" \
  --tenant   "$AZ_TENANT_ID"
az account set --subscription "$AZ_SUBSCRIPTION_ID"
```

- Rotate the secret you posted

```sh
az ad app credential reset --id 7ceabc12-8932-4349-8d3b-75d0c6ea5110 --append --years 1
# Copy the new "password" and update Jenkins Secret Text: az-client-secret
```

- Inside the Jenkins container, we install some dependencies: Azure CLI

```sh
# On the Jenkins agent host (Ubuntu/Debian)
apt-get update -y
apt-get install -y ca-certificates curl apt-transport-https lsb-release gnupg
curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o /usr/share/keyrings/microsoft.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ $(lsb_release -cs) main" | tee /etc/apt/sources.list.d/azure-cli.list
apt-get update -y
apt-get install -y azure-cli git unzip gettext-base jq
```
