# Overview

- Create the VM to practice and it will be automatically stopped if it is not used for a short time 15mins [Done]
- Basically, the VM will cost the user when the VM having the status running, so it is really useful of we stop the VM when not using. So we can use Automation Account with Runbook to achieve that [Done]
- Create the VM via Azure Portal, CLI, ARM templates [Done]
- Learn how to scale, and try to reproduce [TODO]
- Config VNet, Subnet, Public, IP, and NSGs [TODO]
- Disk & Storage and Snapshots & Backups [TODO]
- Basic Monitoring & Alerts [TODO]
- Basic Automation Deploy and manage VMs using ARM Templates, Bicep, and PowerShell scripts. [TODO]

# =======

# Create the VM and Automation Account to automate stopping the VM

## 1. Create the VM

- VM name: main-running-vm-cost
- Group name: long-running-gr
- Cost: 10–20$ / months

## 2. Set up the Budget to limit the cost

- Maximum 10$ per month for all Azure resource

## 3. Create the Automation Account

- main-running-vm-cost-auto-stop the same region with VM
- Include Runbook within the script to check the CPU and stop VM at the specific condition

## 4. Turn on Managed Identity for Automation Account

## 5. Grant permission Contributor for that Automation Account

az role assignment create \
 --assignee-object-id <ID> \
 --assignee-principal-type ServicePrincipal \
 --role "Contributor" \
 --scope /subscriptions/<Subscription...>/resourceGroups/long-running-gr

## 6. Import necessary module

- Az.Accounts
- Az.Compute
- Az.Monitor
- Az.Resources

## 7. Create Runbook AutoStopIdleVM within the script to check and stop the VM

## 8. Test the Runbook

## 9. Create the scheduler to automate running Runbook

- That will be run every hour

# =======

# Create the VM via CLI, ARM templates

## 1. Create VM via Azure Portal

![alt text](./images/VM-APT.png)

## 2. Create VM via Azure CLI

- Login

```sh
az login
```

- Create (or reuse) the resource group

```sh
az group create --name temp-gr --location eastasia
```

- Create the second VM

```sh
az vm create \
  --resource-group temp-gr \
  --name test-vm-2 \
  --image Ubuntu2204 \
  --size Standard_B1s \
  --admin-username azureuser \
  --admin-password "azureuser@123" \
  --authentication-type password \
  --zone 1 \
  --public-ip-sku Standard \
  --location eastasia

```

The result could be

```json
{
  "fqdns": "",
  "id": "/subscriptions/a0199a32-e233-4e1d-91de-6deb080a71c5/resourceGroups/temp-gr/providers/Microsoft.Compute/virtualMachines/test-vm-2",
  "location": "eastasia",
  "macAddress": "60-45-BD-55-A9-5C",
  "powerState": "VM running",
  "privateIpAddress": "10.0.0.5",
  "publicIpAddress": "20.2.88.115",
  "resourceGroup": "temp-gr",
  "zones": "1"
}
```

- Open SSH port

```sh
az vm open-port \
  --port 22 \
  --resource-group temp-gr \
  --name test-vm-2
```

- SSH to server

```sh
ssh azureuser@172.16.0.4
```

The result
![alt text](./images/VM-CLI.png)

## 3. Create VM via ARM Template

Create the ARM configuration file `2.vm-template.json`

Run this in Azure CLI

```sh
az group create --name temp-gr --location eastasia

DEPLOY=vm3-$RANDOM

az deployment group validate \
  --resource-group temp-gr \
  --template-file ./scripts/2.vm-template.json \
  --parameters adminPassword="AzureUser@1234" \
  --output json

az deployment group create \
  --name $DEPLOY \
  --resource-group temp-gr \
  --template-file ./scripts/2.vm-template.json \
  --parameters adminPassword="AzureUser@1234" \
  --output json
```

_We can replace validate/create by what-if to see the preview of deployment_

The result
![alt text](./images/VM-ARM.png)

# =======

# Learn how to scale with VMSS and LB

- Create VM Scale Set: `web-vmss`
- Create Load Balancer `web-vmss-lb` and assign to that VMSS
  - Frontend IP configuration: default Public IP
  - Backend pool: automatically created
  - Load balancing rule
- Attach your VMSS to the backend pool as IP configurations
- Access to VMSS instance
  - Need to Upgrade the VMSS instance
  - Serial console or Bastion
  - If cannot access, we can reset password (azureuser/Azureuser@123)
  - Need to add outbound for the LB, in that case, we can install Nginx inside the VM via APT
- Update the content of Nginx return differently between two Instance

- Set up Autoscale for VMSS
- Inside the VM instance, install stress tool
- Observe Autoscaling in Action, it will be automatically increased

# Learn how to scale with VMSS and LB - Custom Nginx - Enhance

- Create VMSS, config Healthy check
- Add NSG for VMSS
- Add LB for that VMSS
  -> Web automatically run
- Config the backend pool to point to correct network and VMSS
- After associate LB with backend pool, we will need to upgrade the VM

- we can test by using terminal

- Run multiple curls with a random source port

for i in {1..20}; do curl http://20.24.80.83/; done

- Request Flow

```cs
┌──────────────────────────────────────────────────────────────────────────────┐
│                                🌎 CLIENT LAYER                               │
│──────────────────────────────────────────────────────────────────────────────│
│ • User / Browser / Curl command sends HTTP request                           │
│ • Example: http://<Public-IP> (port 80)                                      │
│ • This request travels through the Internet to Azure's public network edge   │
└──────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                          🧩 AZURE LOAD BALANCER (L4)                         │
│──────────────────────────────────────────────────────────────────────────────│
│ **Purpose:** Entry point for external traffic; distributes requests to VMs   │
│ **Components:**                                                              │
│   🔹 *Frontend IP Configuration*                                             │
│       - Public IP: `web-vmss-pip` (Static, Standard SKU)                     │
│       - Receives traffic on port 80                                          │
│                                                                              │
│   🔹 *Backend Pool*                                                          │
│       - Contains private NICs of all VMSS instances                          │
│       - Example: `web-backend`                                               │
│                                                                              │
│   🔹 *Health Probe*                                                          │
│       - Periodically checks VM health                                        │
│       - Config: HTTP GET / on port 80 every 5s                               │
│       - Healthy = responds 200 OK                                            │
│       - Unhealthy = removed from rotation                                   │
│                                                                              │
│   🔹 *Load Balancing Rule*                                                   │
│       - Forwards incoming traffic                                            │
│         Frontend Port 80  →  Backend Port 80                                 │
│       - Uses probe results to pick healthy VMs                              │
│       - Session persistence: `None` (round-robin)                            │
│                                                                              │
│ **Flow:**                                                                    │
│ 1. Client hits Public IP on port 80                                          │
│ 2. LB chooses a *healthy backend instance*                                   │
│ 3. LB forwards the TCP packet to that VM's private IP (port 80)              │
└──────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                      🕸️  AZURE VIRTUAL NETWORK (VNET)                       │
│──────────────────────────────────────────────────────────────────────────────│
│ **Purpose:** Provides private connectivity between LB and VMSS instances     │
│ **Components:**                                                              │
│   🔹 Virtual Network: `web-vnet`                                             │
│   🔹 Subnet: `web-subnet`                                                    │
│   🔹 Private IP range: e.g., 10.0.0.0/24                                     │
│                                                                              │
│ **Flow:**                                                                    │
│ - The Load Balancer communicates with VMs through their private IPs.         │
│ - Traffic never leaves this private network internally.                      │
└──────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│               ⚙️  NETWORK SECURITY GROUP (NSG) – FIREWALL LAYER              │
│──────────────────────────────────────────────────────────────────────────────│
│ **Purpose:** Controls what inbound/outbound traffic can reach VM instances   │
│ **Typical Inbound Rule:**                                                    │
│   • Priority: 1000                                                           │
│   • Name: Allow-HTTP                                                         │
│   • Protocol: TCP                                                            │
│   • Port: 80                                                                 │
│   • Source: Any                                                              │
│   • Action: Allow                                                            │
│                                                                              │
│ **Flow:**                                                                    │
│ - The NSG allows LB health probes and HTTP traffic into the VM’s port 80.    │
│ - Denies all other inbound ports by default.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                     🧮  VIRTUAL MACHINE SCALE SET (VMSS)                     │
│──────────────────────────────────────────────────────────────────────────────│
│ **Purpose:** Auto-manages identical VM instances for scalability & reliability│
│ **Key Properties:**                                                          │
│   🔹 Scale mode: Manual or Auto (based on CPU, metrics, etc.)                 │
│   🔹 Upgrade policy: Automatic / Manual / Rolling                             │
│   🔹 Attached to backend pool: `web-backend`                                 │
│   🔹 Instances: 2+ VMs (e.g., `web-vmss000000`, `web-vmss000001`)            │
│                                                                              │
│ **Each instance includes:**                                                  │
│   • Ubuntu OS (e.g., 22.04 LTS)                                              │
│   • Cloud-init startup script installing and configuring Nginx:              │
│       #cloud-config                                                          │
│       packages: [nginx]                                                      │
│       runcmd:                                                                │
│         - echo "<html><body><h1>$(hostname)</h1><p>Reboot time: $(date -u)</p></body></html>" > /var/www/html/index.html │
│         - systemctl enable nginx                                             │
│         - systemctl restart nginx                                            │
│                                                                              │
│ **Flow:**                                                                    │
│ 1. LB forwards the request → VM private IP port 80                           │
│ 2. Nginx serves the HTML response                                            │
│ 3. Response travels back through LB                                          │
└──────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                           🌩️  NGINX WEB SERVER                              │
│──────────────────────────────────────────────────────────────────────────────│
│ **Role:** Application running on each VM instance                            │
│ **Behavior:**                                                                │
│ - Listens on port 80                                                         │
│ - Serves `/var/www/html/index.html` with unique hostname + reboot time       │
│ - Confirms the VM is operational (used by LB probe too)                      │
│ **Response Example:**                                                        │
│   <html>                                                                     │
│     <body>                                                                   │
│       <h1>web-vmss000001</h1>                                                │
│       <p>Reboot time: Sun Oct 12 17:25:00 UTC 2025</p>                       │
│     </body>                                                                  │
│   </html>                                                                    │
└──────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                            🔁  RESPONSE FLOW                                │
│──────────────────────────────────────────────────────────────────────────────│
│ 1. Nginx returns HTTP 200 + HTML body to LB                                  │
│ 2. Load Balancer sends it back through its frontend public IP                │
│ 3. Client receives response in browser / curl output                         │
│                                                                              │
│ **Result:**                                                                  │
│ - User sees which VM handled the request                                     │
│ - Load Balancer alternates between healthy VMs (round robin)                 │
│ - If one VM fails → probe marks unhealthy → LB stops routing to it           │
└──────────────────────────────────────────────────────────────────────────────┘
```

# Learn how to scale with VMSS and LB - Custom Nginx - Azure CLI - Enhance

## 1. Variables Setup

```bash
# Set variables
RESOURCE_GROUP="vmss-nginx-rg"
LOCATION="eastasia"
VMSS_NAME="vmss-nginx-test"
ADMIN_USER="azureuser"
ADMIN_PASS="Azureuser@123"
```

## 2. Create Resource Group

```bash
az group create --name $RESOURCE_GROUP --location $LOCATION
```

## 3. Create Public IP + VNet + Subnet + Load Balancer

```bash
# Public IP
az network public-ip create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-pip \
  --sku Standard \
  --allocation-method static

# VNet + Subnet
az network vnet create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-vnet \
  --subnet-name ${VMSS_NAME}-subnet

# Load Balancer
az network lb create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-lb \
  --sku Standard \
  --frontend-ip-name frontend \
  --backend-pool-name backend \
  --public-ip-address ${VMSS_NAME}-pip
```

## 4. Create Health Probe + LB Rule

```bash
az network lb probe create \
  --resource-group $RESOURCE_GROUP \
  --lb-name ${VMSS_NAME}-lb \
  --name http-probe \
  --protocol tcp \
  --port 80

az network lb rule create \
  --resource-group $RESOURCE_GROUP \
  --lb-name ${VMSS_NAME}-lb \
  --name http-rule \
  --protocol tcp \
  --frontend-port 80 \
  --backend-port 80 \
  --frontend-ip-name frontend \
  --backend-pool-name backend \
  --probe-name http-probe

```

## 5. Create VMSS with Custom Data (Install Nginx)

Create the file `./scripts/cloud-init-nginx.yml` with content

```bash
cat <<EOF > ./scripts/cloud-init-nginx.yml
#cloud-config
package_update: true
packages:
  - nginx
runcmd:
  - echo "<h1>Welcome from \$(hostname)</h1><p>Reboot time: \$(date)</p>" > /var/www/html/index.nginx-debian.html
  - systemctl enable nginx
  - systemctl restart nginx
EOF
```

Create VMSS

```bash
az vmss create \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --image Ubuntu2204 \
  --upgrade-policy-mode automatic \
  --admin-username $ADMIN_USER \
  --admin-password $ADMIN_PASS \
  --custom-data ./scripts/cloud-init-nginx.yml \
  --vnet-name ${VMSS_NAME}-vnet \
  --subnet ${VMSS_NAME}-subnet \
  --lb ${VMSS_NAME}-lb \
  --backend-pool-name backend \
  --instance-count 2 \
  --vm-sku Standard_B1s
```

## 6. Open Port 80 for the VMSS

```bash
# Create new NSG
az network nsg create \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-nsg

# Create rule for HTTP
az network nsg rule create \
  --resource-group $RESOURCE_GROUP \
  --nsg-name ${VMSS_NAME}-nsg \
  --name allow-http \
  --protocol Tcp \
  --direction Inbound \
  --priority 1000 \
  --source-address-prefixes '*' \
  --source-port-ranges '*' \
  --destination-port-ranges 80 \
  --access Allow

# Attach NSG to subnet
az network vnet subnet update \
  --resource-group $RESOURCE_GROUP \
  --vnet-name ${VMSS_NAME}-vnet \
  --name ${VMSS_NAME}-subnet \
  --network-security-group ${VMSS_NAME}-nsg
```

## 7. Find the public IP

```bash
az network public-ip show \
  --resource-group $RESOURCE_GROUP \
  --name ${VMSS_NAME}-pip \
  --query "ipAddress" \
  --output tsv
```

# =======

# Learn how to auto scale to deploy the Dotnet App

- Create the simple dotnet app and can be deploy to 3 VM
- LB: 1 - 3 VM
